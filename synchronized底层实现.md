# synchronized底层实现

## 第一阶段
synchronized实现是重量级的，synchronized都是要找操作系统去申请锁, 这样就需要走系统调用、用户态与内核态的转换，所以他的效率就很低.有时候执行代码所需的时间还不如
申请锁状态转换所需的时间长。Java 1.5之后，加了很多concurrent lock的内容和锁的类型，这些锁在JVM内就能实现锁的功能，不需要麻烦OS了，效率会提高，而且用起来也更灵活，
比如ReentrantLock

## 第二阶段
锁升级（《我就是厕所所长》那篇文章）JDK 1.5之后，上来之后去访问，object头上，记录一下markword，实际上没加锁，只是记录线程的ID（偏向锁），默认不会有第二个线程来抢，一看还是这个线程回来访问，不用申请锁
直接开始执行；如果有线程争用，升级为自旋锁：第二个线程来了之后，不到CPU的就绪队列里面，而是就在旁边等着，做一个类似while(true)的自旋等待，10次自旋之后第一个线程还没释放锁，则进入等待队列，锁才会进一步
升级为重量级锁：去操作系统申请资源加锁。有了锁升级之后，synchronized就不见得比AtomicXXX效率低了。自旋的时候虽然占用CPU但是升级为等待队列里的锁的时候就不占用CPU了。锁只能升级不能降级。JVM写得好的话，
也能实现让他降级回来  

什么时候用自旋锁比较好？自旋锁占用CPU，但是不访问操作系统。他在用户态而不是内核态，因此他的效率比较高，加锁代码执行时间长的线程用重量级锁好一些，反之自旋锁比较好，来抢的线程不是很多的时候自旋锁好一些。
同步代码块执行时间短，线程数少 ----- 自旋锁；同步代码块执行时间长、并发的线程数多 ----- 系统锁（重量级锁，切换到内核态）

CAS是Compare And Set的缩写。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了
操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转，翻译成人话就是循环，一般是用一个无限循环实现。compareAndSet 方法，这就是实现 CAS 的核心方法了，在使用 AtomicBoolean 的这个方法
时，只需要传递期望值和待更新的值即可，而它里面调用了 unsafe.compareAndSwapInt(this, valueOffset, e, u) 方法，它是个 native 方法，用 c++ 实现，具体的代码就不贴了，总之是利用了 CPU 的 cmpxchg 
指令完成比较并替换，当然根据具体的系统版本不同，实现起来也有所区别。
```
m = 0;
m++;
CAS(0, 1)

expected = read m
//这里有人改过就重新读
CAS(expected=0, update=1) {
	while (true) {
		if (m == 0) {
			m = m + 1;
			break;
		}
	}
}
```
就是了乐观锁的概念，默认没人改过，一旦有人改就等待，比如m变成1了，则CAS变成了CAS(1,2)，期望值要先读一下，无锁操作。其中CAS伪方法代码在CPU原语层面上被保证了原子性，CPU直接修改那块内存的值
注：Unsafe这个类在1.9之后不让用了. CAS调用了native，而且有@HotSpotIntrinsicCandidate注解，Java 9引入的新特性，作用如下：  
JDK的源码中，被@HotSpotIntrinsicCandidate标注的方法，在HotSpot中都有一套高效的实现，该高效实现基于CPU指令，运行时，HotSpot维护的高效实现会替代JDK
的源码实现，从而获得更高的效率。  

用户态和内核态的比较：  
应用程序和系统内核各占一部分内存。Linux内核可以访问所有的内存，包括自己的和用户的，而应用程序无法访问内核占用的内存。用户态访问内存有更多的限制，用户的应用程序有时候要通过内核帮他完成一些事情，比如启动、
关闭、切换一个线程

https://blog.csdn.net/xiuye2015/article/details/53406432