# synchronized底层实现

## 第一阶段
synchronized实现是重量级的，synchronized都是要找操作系统去申请锁, 这样他的效率就很低

## 第二阶段
锁升级（《我就是厕所所长》那篇文章）JDK 1.5之后，上来之后去访问，object头上，记录一下markword，实际上没加锁，只是记录线程的ID（偏向锁），默认不会有第二个线程来抢，一看还是这个线程回来访问，不用申请锁
直接开始执行；如果有线程争用，升级为自旋锁：第二个线程来了之后，不到CPU的就绪队列里面，而是就在旁边等着，做一个类似while(true)的自旋等待，10次自旋之后第一个线程还没释放锁，则进入等待队列，锁才会进一步
升级为重量级锁：去操作系统申请资源加锁。有了锁升级之后，synchronized就不见得比AtomicXXX效率低了。自旋的时候虽然占用CPU但是升级为等待队列里的锁的时候就不占用CPU了。锁只能升级不能降级。JVM写得好的话，
也能实现让他降级回来  

什么时候有自旋锁比较好？自旋锁占用CPU，但是不访问操作系统。他在用户态而不是内核态，因此他的效率比较高，加锁代码执行时间长的线程用重量级锁好一些，反之自旋锁比较好，来抢的线程不是很多的时候自旋锁好一些。
同步代码块执行时间短，线程数少 ----- 自旋锁；同步代码块执行时间长线程数多 ----- 系统锁（重量级锁，切换到内核态）

CAS是Compare And Set的缩写。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS 是实现自旋锁的基础，CAS 利用 CPU 指令保证了
操作的原子性，以达到锁的效果，至于自旋呢，看字面意思也很明白，自己旋转，翻译成人话就是循环，一般是用一个无限循环实现。compareAndSet 方法，这就是实现 CAS 的核心方法了，在使用 AtomicBoolean 的这个方法
时，只需要传递期望值和待更新的值即可，而它里面调用了 unsafe.compareAndSwapInt(this, valueOffset, e, u) 方法，它是个 native 方法，用 c++ 实现，具体的代码就不贴了，总之是利用了 CPU 的 cmpxchg 
指令完成比较并替换，当然根据具体的系统版本不同，实现起来也有所区别。